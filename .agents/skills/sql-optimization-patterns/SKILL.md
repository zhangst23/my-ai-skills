---
name: "sql-optimization-patterns"
description: "提供 SQL 性能优化的模式、技巧和手册。当用户需要优化数据库查询、设计索引或改进数据库架构性能时调用此技能。"
metadata:
  version: 1.0.0
---

# SQL 性能优化手册

你是一位资深的数据库管理员和 SQL 优化专家。你的目标是提供实用、高效且可落地的 SQL 优化建议。

## 核心优化原则

### 1. 减少数据访问量
- **只查询需要的列**：避免使用 `SELECT *`，减少网络传输和内存开销。
- **使用 WHERE 子句**：尽早过滤掉不必要的数据。
- **分页查询**：对于大数据量，务必使用 `LIMIT` / `OFFSET` 或基于游标的分页。

### 2. 索引优化模式

#### 覆盖索引 (Covering Index)
如果一个索引包含了查询所需的所有列，数据库就不需要再回表查询行数据。
- **模式**：`CREATE INDEX idx_user_email_name ON users(email, name);`
- **适用**：经常一起查询的字段。

#### 最左前缀原则
在联合索引中，查询条件必须从索引的最左侧列开始，否则索引可能失效。
- **模式**：索引为 `(A, B, C)`，支持 `A`, `A,B`, `A,B,C` 的查询。

#### 避免索引失效
- 避免在索引列上使用函数或运算：`WHERE YEAR(date) = 2023` -> `WHERE date >= '2023-01-01'`。
- 避免不匹配的数据类型转换。
- `LIKE` 查询避免以通配符开头：`LIKE '%term'` 会导致全表扫描。

### 3. 查询重写技巧

#### EXISTS vs IN
- 通常 `EXISTS` 在子查询结果集较大时性能更好。
- `IN` 适合子查询结果集较小的情况。

#### JOIN 优化
- **小表驱动大表**：确保 JOIN 的顺序是先处理数据量较小的表。
- **确保连接字段有索引**。
- **避免笛卡尔积**：检查 JOIN 条件是否完整。

#### 聚合优化
- 在聚合前先进行过滤 (`WHERE`)，而不是在聚合后过滤 (`HAVING`)。

### 4. 架构设计模式

#### 规范化与反规范化
- **规范化**减少冗余，但在复杂查询中会导致过多的 JOIN。
- **反规范化**（如增加冗余字段）可以减少 JOIN，提高查询速度，但会增加写入开销和维护难度。

#### 分库分表
- **垂直拆分**：按功能模块将表分到不同数据库。
- **水平拆分**：将同一个表的数据按某种规则（如 ID 取模）分布到多个表或库中。

---

## 性能诊断工具
建议用户提供以下信息以便深入分析：
1.  **EXPLAIN 输出**：查看执行计划。
2.  **表结构 (DDL)**：了解字段类型和现有索引。
3.  **数据量级**：了解表的行数。
4.  **慢查询日志**：具体的 SQL 语句和执行时间。

---

## 最佳实践检查清单
- [ ] 是否存在全表扫描？
- [ ] 是否利用了合适的索引？
- [ ] 查询是否可以缓存？
- [ ] 是否存在 N+1 查询问题？
- [ ] 事务是否过长？
